## fxxk
多线程实现有个死锁问题。`Cancel`时如果最终调用了`lock(xxx)`会发生死锁。
没找到问题。
排除的几个问题
1. `lock(this)`和`lock(m_lock_obj)`效果一样

找到问题了。
Winform的UI事件响应时也有一个锁，`Control.Invoke`时就要获取这把锁。
工作线程用this作为锁。
这样就有两把锁，且UI线程和工作线程都有使用了，然后就死锁了。
解决办法是：**不要同时锁上两把锁**，不要在一个锁的区域内获取另外的锁。UI线程控制不了，调整下自己的工作线程逻辑。
思索：
1. go语言的channel把锁封装在了内部，这样一次只会用到一把锁，值得参考。
2. 获取管理对象状态时还是直接访问属性的方便，用锁比较方便，用channel之类的思路就麻烦了。不过不小心调用个回调可能就死锁了。
  - 也许可以采用汇报状态的做法。
3. 日志和日志的显示可以，现在的处理很浪费。
